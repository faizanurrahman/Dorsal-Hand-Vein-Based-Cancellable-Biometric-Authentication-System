# Evaluates the results produced by the "nn_classification_PhD" function
#
# PROTOTYPE
# output = evaluate_results_PhD(results,decision_mode,results1);
#
# USAGE EXAMPLE(S)
#
#     Example 1:
#       # we randomly generate a few 100-dimensional training and testing
#       # feature vectors belonging to 20 classes;
#       # this shows the use of the 'ID' option
#         n=100;
#         train_feature_vectors=[];
#         test_feature_vectors=[];
#         test_ids = [];
#         train_ids = [];
#         for i=1:20
#             for j=1:10
#                 train_feature_vectors=[train_feature_vectors,i+1.5*randn(n,1)];
#                 train_ids = [train_ids,i];
#                 test_feature_vectors=[test_feature_vectors,i+1.5*randn(n,1)];
#                 test_ids = [test_ids,i];
#             end
#         end
#         results = nn_classification_PhD(train_feature_vectors, train_ids, test_feature_vectors, test_ids, n, 'euc','all');
#         output = evaluate_results_PhD(results,'ID');
#
#
#     Example 2:
#       # we randomly generate a few 100-dimensional training and testing
#       # feature vectors belonging to 20 classes;
#       # this shows the use of the 'image' option
#         n=100;
#         train_feature_vectors=[];
#         test_feature_vectors=[];
#         test_ids = [];
#         train_ids = [];
#         for i=1:20
#             for j=1:10
#                 train_feature_vectors=[train_feature_vectors,i+1.5*randn(n,1)];
#                 train_ids = [train_ids,i];
#                 test_feature_vectors=[test_feature_vectors,i+1.5*randn(n,1)];
#                 test_ids = [test_ids,i];
#             end
#         end
#         results = nn_classification_PhD(train_feature_vectors, train_ids, test_feature_vectors, test_ids, n, 'euc','all');
#         output = evaluate_results_PhD(results,'image');
#
#     Example 3:
#       # we randomly generate a few 100-dimensional training, testing and
#       # evaluation feature vectors belonging to 20 classes;
#       # this shows the use of the 'ID' option and two results structures
#         n=100;
#         train_feature_vectors=[];
#         test_feature_vectors=[];
#         eval_feature_vectors=[];
#         test_ids = [];
#         train_ids = [];
#         eval_ids = [];
#         for i=1:20
#             for j=1:10
#               if(i<10)
#                 train_feature_vectors=[train_feature_vectors,i+1.5*randn(n,1)];
#                 train_ids = [train_ids,i];
#               end
#                 test_feature_vectors=[test_feature_vectors,i+1.5*randn(n,1)];
#                 test_ids = [test_ids,i];
#                 eval_feature_vectors=[eval_feature_vectors,i+1.5*randn(n,1)];
#                 eval_ids = [eval_ids,i];
#             end
#         end
#         results = nn_classification_PhD(train_feature_vectors, train_ids, test_feature_vectors, test_ids, n, 'euc','sep');
#         results1 = nn_classification_PhD(train_feature_vectors, train_ids, eval_feature_vectors, eval_ids, n, 'euc','sep');
#         output = evaluate_results_PhD(results,'image',results1);
#
#
# GENERAL DESCRIPTION
# The function evaluates the similarity matrix in the input results
# structure that was produced using the "nn_classification_PhD" function
# from the PhD toolbox and produces performance metrics from the similarity
# matrix. These metrics include: the equal error rate, the verification
# rates at 1#, 0.1# and 1 FAR, the minimal half total eror rate, the rank
# one recognition rate etc. The function also computes ROC and CMC curve
# data that can be used to plot ROC and CMC curves.
#
# If three inout arguments are provided to the function, it also computes
# EPC curve data that can be used to plot exepcted performance curves. If
# you have installed NISTs DETware, the function also computed DET curve
# data.
#
# The function operates in to distinct modes, where the results are
# generated in two slightly different ways. If the "decision_mode" input
# argument is set "ID" then all target feature vectors belonging to the
# same ID are considered to comprise the IDs template (e.g., if four scores
# were generated using target feature vectors with the same ID, the median
# of these scores is used to make a decision regarding the identity). If
# the "decision_mode" input argument is set to "image" then the results are
# generated as if pairwise comparison were being made. This means that the
# templates are considered to be comprised of a single feature vector.
#
# To see an example of usage of the function look at the examples above or
# find an appropriate demo in the demo folder.
#
#
# REFERENCES
# There are no specific references linked to this function. Some
# information on the results generated by this function (e.g., ROC, CMC,
# EPC curves) can be found in:
#
# Štruc V., Pavešic, N.: The Complete Gabor-Fisher Classifier for Robust
# Face Recognition, EURASIP Advances in Signal Processing, vol. 2010, 26
# pages, doi:10.1155/2010/847680, 2010.
#
#
#
# INPUTS:
# results               - a result structure generated through the use of
#                         the "nn_classification_PhD" function (obligaotry);
#                         for more information on this structure please
#                         type:
#                               help nn_classification_PhD
# decision_mode         - a string defining the decision mode based on
#                         which to produce the results (optional argument);
#                         valid values:
#                                       'ID' (default)| 'image'
# results1              - a result structure generated through the use of
#                         the "nn_classification_PhD" function (optional);
#                         note that this structure needs to be generated
#                         using test data that is different from that used
#                         to produce the result structure that represents
#                         the obligatory argument to this function; if this
#                         structure is omitted, the function simply skips
#                         the EPC curve calculation that requires additional
#                         matching results
#
# OUTPUTS:
# output                - an output structure with performance metrics
#                         computed from the similarity matrix; the
#                         structure contains several fields, which are
#                         dependant on the input arguments and installed
#                         software (i.e., if DETware is installed or not).
#                         In its most complete form the structure contains
#                         the following fields:
#
#  output.ROC_ver_rate      ... a vector of verification rates that
#                               represents y-axis data of the computed ROC
#                               curve
#  output.ROC_miss_rate     ... a vector of miss rates (false acceptance
#                               rates) that represents x-axis data of the
#                               computed ROC curve
#  output.ROC_char_errors   ... a structure of characteristic error rates
#                               computed from the similarity matrix; it
#                               contains the following fields:
#
#       .minHTER_er     ... the minimal achievable half total error rate
#       .minHTER_tr     ... the decision threshold that ensures the above
#                           minimal half total error rate
#       .minHTER_frr    ... the false rejection error rate at the minimal
#                           Half total error rate
#       .minHTER_ver    ... the verification rate at the minimal half
#                           total error rate
#       .minHTER_far    ... the false acceptance error rate at the minimal
#                           half total error rate
#       .EER_er         ... the equal error rate
#       .EER_tr         ... the decision threshold that ensures the above
#                           equal error rate
#       .EER_frr        ... the false rejection error rate at the equal
#                           error rate
#       .EER_ver        ... the verification rate at the equal error rate
#       .FRR_01FAR_er   ... the half total error rate at the operating
#                           point where FRR = 0.1*FAR
#       .FRR_01FAR_tr   ... the decision threshold that ensures the above
#                           half total error rate of FRR = 0.1*FAR
#       .FRR_01FAR_frr  ... the false rejection error rate at the half
#                           total error rate of FRR = 0.1*FAR
#       .FRR_01FAR_ver  ... the verification rate at the half
#                           total error rate of FRR = 0.1*FAR
#       .FRR_01FAR_far  ... the false acceptance error rate at the half
#                           total error rate of FRR = 0.1*FAR
#       .FRR_10FAR_er   ... the half total error rate at the operating
#                           point where FRR = 10*FAR
#       .FRR_10FAR_tr   ... the decision threshold that ensures the above
#                           half total error rate of FRR = 10*FAR
#       .FRR_10FAR_frr  ... the false rejection error rate at the half
#                           total error rate of FRR = 10*FAR
#       .FRR_10FAR_ver  ... the verification rate at the half
#                           total error rate of FRR = 10*FAR
#       .FRR_10FAR_far  ... the false acceptance error rate at the half
#                           total error rate of FRR = 10*FAR
#       ...
#
#       more ...
#
#       For more information on this structure have a look at the
#       "rates_and_threshs" structure of the "produce_ROC_PhD" function.
#       The two structures are identical.
#
#  output.DET_frr_rate      ... a vector of false rejection rates that
#                               represent y-axis data of the computed DET
#                               curve (this field is only available if
#                               NISTs DETware is installed)
#  output.DET_far_rate      ... a vector of false acceptance rates that
#                               represent x-axis data of the computed DET
#                               curve (this field is only available if
#                               NISTs DETware is installed)
#  output.CMC_rec_rates     ... a vector of recognition rates that
#                               represent y-axis data of the computed CMC
#                               curve; NOTE!!: output.CMC_rec_rates(1)
#                               represents the rank one recognition rate
#  output.CMC_ranks         ... a vector of ranks that corresponds to the
#                               recognition rates in "output.CMC_rec_rates";
#                               the data represents x-axis data of the
#                               computed CMC curve
#  output.EPC_char_errors   ... a structure of characteristical error
#                               rates on the EPC curve; for a more detailed
#                               description of this structure look at the
#                               "rates_and_threshs1" output structure of
#                               the "produce_EPC_PhD" function; the two
#                               structures are identical
#  output.EPC_alpha         ... a vector of alpha values that represents
#                               x-axis data of the computed EPC curve;
#                               (this field is only available if two
#                               results structures obtained on test as well
#                               as evaluation data are provided as input to
#                               the function)
#  output.EPC_errors        ... a vector of error rates that represents
#                               y-axis data of the computed EPC curve;
#                               (this field is only available if two
#                               results structures obtained on test as well
#                               as evaluation data are provided as input to
#                               the function)
#
# NOTES / COMMENTS
# The function was tested with Matlab ver. 7.9.0.529 (R2009b) and Matlab
# ver. 7.11.0.584 (R2010b).
#
#
# RELATED FUNCTIONS (SEE ALSO)
# nn_classification_PhD
# return_distance_PhD
#
#
# ABOUT
# Created:        10.2.2010
# Last Update:    21.12.2011
# Revision:       1.0
#
#
# WHEN PUBLISHING A PAPER AS A RESULT OF RESEARCH CONDUCTED BY USING THIS CODE
# OR ANY PART OF IT, MAKE A REFERENCE TO THE FOLLOWING PUBLICATIONS:
#
# Štruc V., Pavešic, N.: The Complete Gabor-Fisher Classifier for Robust
# Face Recognition, EURASIP Advances in Signal Processing, vol. 2010, 26
# pages, doi:10.1155/2010/847680, 2010.
#
# Štruc V., Pavešic, N.:Gabor-Based Kernel Partial-Least-Squares
# Discrimination Features for Face Recognition, Informatica (Vilnius), vol.
# 20, no. 1, pp. 115-138, 2009.
#
#
# The BibTex entries for the papers are here
#
# @Article{ACKNOWL1,
#     author = "Vitomir \v{S}truc and Nikola Pave\v{s}i\'{c}",
#     title  = "The Complete Gabor-Fisher Classifier for Robust Face Recognition",
#     journal = "EURASIP Advances in Signal Processing",
#     volume = "2010",
#     pages = "26",
#     year = "2010",
# }
#
# @Article{ACKNOWL2,
#     author = "Vitomir \v{S}truc and Nikola Pave\v{s}i\'{c}",
#     title  = "Gabor-Based Kernel Partial-Least-Squares Discrimination Features for Face Recognition",
#     journal = "Informatica (Vilnius)",
#     volume = "20",
#     number = "1",
#     pages = "115–138",
#     year = "2009",
# }
#
# Official website:
# If you have down-loaded the toolbox from any other location than the
# official website, plese check the following link to make sure that you
# have the most recent version:
#
# http://luks.fe.uni-lj.si/sl/osebje/vitomir/face_tools/PhDface/index.html
#
#
# OTHER TOOLBOXES
# If you are interested in face recognition you are invited to have a look
# at the INface toolbox as well. It contains implementations of several
# state-of-the-art photometric normalization techniques that can further
# improve the face recognition performance, especcially in difficult
# illumination conditions. The toolbox is available from:
#
# http://luks.fe.uni-lj.si/sl/osebje/vitomir/face_tools/INFace/index.html
#
#
# Copyright (c) 2011 Vitomir Štruc
# Faculty of Electrical Engineering,
# University of Ljubljana, Slovenia
# http://luks.fe.uni-lj.si/en/staff/vitomir/index.html
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files, to deal
# in the Software without restriction, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# The Software is provided "as is", without warranty of any kind.
#
# December 2011

class Output(object):
	def __init__(self):
		dummy = 0


import numpy as np


def evaluate_results_PhD(results, decision_mode):
	## Init
	output = Output();

	## Check inputs
	EPC_flag = 0;

	# check input arguments
	'''
	if nargin <1
		print('The function requires at least one input argument!')
		return;
	elseif nargin >3
		print('The function takes no more than three input arguments!')
		return;
	elseif nargin == 1
		decision_mode = 'ID';
	elseif nargin == 2
		if ischar(decision_mode)~=1
			print('The "decision_mode" parameter must be a string.')
			return;
		end
		if strcmp(decision_mode,'ID')==1 || strcmp(decision_mode,'image')==1
			#ok
		else
			print('The "decision mode" parameter is not valid: ID | image.')
			return;
		end
	elseif nargin == 3
		EPC_flag=1;
		if ischar(decision_mode)~=1
			print('The "decision_mode" parameter must be a string.')
			return;
		end

		if strcmp(decision_mode,'ID')==1 || strcmp(decision_mode,'image')==1
		else
			print('The "decision mode" parameter is not valid: ID | image.')
			return;
		end
		print('Note that two input structures are used solely for producing verification rates at certain thresholds!')
		print('This will produce verification rates at certain operating points as well as EPC curve data!')
		print('In the computation the first input structure will be used for threshold calculation and the second for verification rate calculation.')
	end

	#check for mode
	if isfield(results,'mode') ~= 1
		print('The results structure contains no definition for "mode". Missing results.mode!');
		return;
	end
	'''

	# check which mode was used
	'''
	if strcmp(results.mode,'sep')==1
	   if isfield(results,'dist')~=1
		   print('The specification about the employed distance could not be found. Missing results.dist!')
		   return;
	   end

	   if isfield(results,'dim')~=1
		   print('The specification about the employed feature-dimensionality could not be found. Missing results.dim!')
		   return;
	   end

	   if isfield(results,'client_dist')~=1
		   print('Could not find the client distances. Missing results.client_dist!')
		   return;
	   end

	   if isfield(results,'same_cli_id')~=1
		   print('Could not find the Id info. Missing results.same_cli_id!')
		   return;
	   end

	   if isfield(results,'client_horizontal_ids')~=1
		   print('Could not find client ID info. Missing results.client_horizontal_ids!')
		   return;
	   end

	   if isfield(results,'client_vertical_ids')~=1
		   print('Could not find the client ID info. Missing results.client_vertical_ids!')
		   return;
	   end

	   if isfield(results,'imp_dist')~=1
		   print('Could not find the impostor distances. Missing results.imp_dist!')
		   return;
	   end

	   if isfield(results,'same_imp_id')~=1
		   print('Could not find the impostor ID info. Missing results.same_imp_id!')
		   return;
	   end

	   if isfield(results,'imp_vertical_ids')~=1
		   print('Could not find the impostor ID info. Missing results.imp_vertical_ids!')
		   return;
	   end

	   if isfield(results,'imp_horizontal_ids')~=1
		   print('Could not find the impostor ID info. Missing results.imp_horizontal_ids!')
		   return;
	   end
	'''
	'''   
	if results.mode=='all':
	#     if nargin == 3
	#         print('The second input structure with results can be used only in the separation mode!')
	#         return;
	#     end

		if isfield(results,'dist')~=1
		   print('The specification about the employed distance could not be found. Missing results.dist!')
		   return;
	   end

	   if isfield(results,'dim')~=1
		   print('The specification about the employed feature-dimensionality could not be found. Missing results.dim!')
		   return;
	   end

	#    if isfield(results,'same_id')~=1
	#        print('Could not find the ID info. Missing results.same_id!')
	#        return;
	#    end

	   if isfield(results,'dist')~=1
		   print('Could not find the similarity matrix. Missing results.match_dist!')
		   return;
	   end

	   if isfield(results,'horizontal_ids')~=1
		   print('Could not find the ID info. Missing results.horizontal_ids!')
		   return;
	   end

	   if isfield(results,'vertical_ids')~=1
		   print('Could not find the ID info. Missing results.vertical_ids!')
		   return;
	   end
	else
		print('The input "mode" was not recognized as a valid mode!')
		return;
	end


	'''
	## Generate results - mode-wise
	'''
	if strcmp(results.mode,'sep')==1

		#account for decision mode
		if strcmp(decision_mode,'ID')==1

			#compute ROC and DET data
			print('Computing ROC and DET curves ...')

			#get client distances (median distance in each ID)
			unique_cli_id = unique(results.client_horizontal_ids);
			[y,x] = find(results.same_cli_id==1);
			[Y,X] = meshgrid(results.client_vertical_ids,results.client_horizontal_ids);
			Y=X';
			[y_siz,x_siz] = size(results.same_cli_id);

			client_coors = [y,x];
			cont = 1;
			for i=1:length(unique_cli_id)

				#find i-th ID that corresponds to client coors
				[y,x] = find(unique_cli_id(i)==Y);
				ID_coors = [y,x];
				score_coors = intersect(ID_coors, client_coors,'rows');

				#look at size of ID client matches - there can be more than one
				same_test_ID = unique(score_coors(:,1)); #get the unique y coordinates of the same test

				for j=1:length(same_test_ID)
					[y,x]=find(same_test_ID(j)==score_coors(:,1));
					scores_c = sub2ind(size(results.same_cli_id),score_coors(y,1),score_coors(y,2));#[score_coors(y,1),score_coors(y,2)];
					d_client(1,cont) = (median(results.client_dist(scores_c)));
					cont=cont+1;
				end
			end


			#get impostor distances (median distance in each ID)
			[imp_siz,dumm] = size(results.imp_dist);
			[Y,X] = meshgrid(1:imp_siz,results.client_horizontal_ids);
			Y=X'; #this is ok now - I could also adjust (transpose and change?) the above inputs 
			cont = 1;
			d_impostor = zeros(1,length(unique(results.imp_horizontal_ids))*length(results.imp_vertical_ids));
			for i=1:length(unique_cli_id)

				#find i-th ID that corresponds to client coors
				[y,x] = find(unique_cli_id(i)==Y);
				ID_coors = [y,x];

				#look each test of the same query on the same ID
				test_ID = unique(ID_coors(:,1)); #get the unique y coordinates of the same test

				for j=1:length(test_ID)
					[y,x]=find(test_ID(j)==ID_coors(:,1));
					scores_c = sub2ind(size(results.imp_dist),ID_coors(y,1),ID_coors(y,2));#[score_coors(y,1),score_coors(y,2)];
					d_impostor(1,cont) = (median(results.imp_dist(scores_c)));
					cont=cont+1;
				end
			end


			#compute ROC curve
			[ver_rate, miss_rate, rates_and_threshs] = produce_ROC_PhD(d_client, d_impostor, 5000);


			#set ROC outputs
			output.ROC_ver_rate = ver_rate;
			output.ROC_miss_rate = miss_rate;
			output.ROC_char_errors = rates_and_threshs;

			#report to prompt
			print('Finished with ROC, starting with DET if available.')

			#try to use Nists DET-ware; if not available report in skip
			try
				#compute DET data
				[Pmiss, Pfa] = Compute_DET(-d_client, -d_impostor);

				#set DET outputs
				output.DET_frr_rate = Pmiss;
				output.DET_far_rate = Pfa;    
				print('Finished with DETs!')
			catch
			   print('No DET-ware installed or not in Matlabs path! Make sure that NISTs DET-ware is present on your machine.')
			   print('You can download a gzipped tar-ball of the software from: http://www.itl.nist.gov/iad/mig/tools/DETware_v2.1.targz.htm')
			end


			#report to prompt
			print('Computing CMC curves ...')

			#finally we compute the cumulative match score curves - CMCs
			[rec_rates, ranks] = produce_CMC_PhD(results);


			#set CMC outputs
			output.CMC_rec_rates = rec_rates;
			output.CMC_ranks = ranks;

			print('Finished with CMCs!')


			#compute EPC curves if specified
			if EPC_flag==1

				#report to prompt
				print('Computing EPC curves and independant evaluation error rates ...')

				#as for the ROC curves - extract client and impostor scores

				#get client distances (median distance in each ID)
				unique_cli_id = unique(results1.client_horizontal_ids);
				[y,x] = find(results1.same_cli_id==1);
				[Y,X] = meshgrid(results1.client_vertical_ids,results1.client_horizontal_ids);
				Y=X';
				[y_siz,x_siz] = size(results1.same_cli_id);

				client_coors = [y,x];
				cont = 1;
				for i=1:length(unique_cli_id)

					#find i-th ID that corresponds to client coors
					[y,x] = find(unique_cli_id(i)==Y);
					ID_coors = [y,x];
					score_coors = intersect(ID_coors, client_coors,'rows');

					#look at size of ID client matches - there can be more than one
					same_test_ID = unique(score_coors(:,1)); #get the unique y coordinates of the same test

					for j=1:length(same_test_ID)
						[y,x]=find(same_test_ID(j)==score_coors(:,1));
						scores_c = sub2ind(size(results1.same_cli_id),score_coors(y,1),score_coors(y,2));#[score_coors(y,1),score_coors(y,2)];
						d_client1(1,cont) = (median(results1.client_dist(scores_c)));
						cont=cont+1;
					end
				end


				#get impostor distances (median distance in each ID)
				[imp_siz,dumm] = size(results1.imp_dist);
				[Y,X] = meshgrid(1:imp_siz,results1.client_horizontal_ids);
				Y=X'; #this is ok now - I could also adjust (transpose and change?) the above inputs 
				cont = 1;
				d_impostor1 = zeros(1,length(unique(results1.imp_horizontal_ids))*length(results1.imp_vertical_ids));
				for i=1:length(unique_cli_id)

					#find i-th ID that corresponds to client coors
					[y,x] = find(unique_cli_id(i)==Y);
					ID_coors = [y,x];

					#look each test of the same query on the same ID
					test_ID = unique(ID_coors(:,1)); #get the unique y coordinates of the same test

					for j=1:length(test_ID)
						[y,x]=find(test_ID(j)==ID_coors(:,1));
						scores_c = sub2ind(size(results1.imp_dist),ID_coors(y,1),ID_coors(y,2));#[score_coors(y,1),score_coors(y,2)];
						d_impostor1(1,cont) = (median(results1.imp_dist(scores_c)));
						cont=cont+1;
					end
				end


				#compute EPC curves
				[alpha,errors,rates_and_threshs1] = produce_EPC_PhD(d_client,d_impostor,d_client1,d_impostor1,rates_and_threshs,100);

				#set EPC outputs
				output.EPC_char_errors = rates_and_threshs1;
				output.EPC_alpha = alpha;
				output.EPC_errors = errors;    
			end    
		elseif strcmp(decision_mode,'image')==1

			#compute ROC and DET data
			print('Computing ROC and DET curves ...')

			#get client distances
			cont_c = 1;
			for i=1:length(results.client_horizontal_ids)
				for j=1:length(results.client_vertical_ids)
					if results.client_horizontal_ids(1,i)==results.client_vertical_ids(1,j)
						d_client(1,cont_c) = results.client_dist(j,i);
						cont_c=cont_c+1;
					end 
				end
			end

			#get impostor distances 
			d_impostor = zeros(1,length(results.imp_horizontal_ids)*length(results.imp_vertical_ids));
			cont = 1;
			for i=1:length(results.imp_horizontal_ids)
				for j=1:length(results.imp_vertical_ids)
					d_impostor(1,cont) = results.imp_dist(j,i);
					cont=cont+1;
				end
			end

			#compute ROC curve
			[ver_rate, miss_rate, rates_and_threshs] = produce_ROC_PhD(d_client, d_impostor, 5000);


			#set ROC outputs
			output.ROC_ver_rate = ver_rate;
			output.ROC_miss_rate = miss_rate;
			output.ROC_char_errors = rates_and_threshs;


			#report to prompt
			print('Finished with ROC, starting with DET if available.')

			#try to use Nists DET-ware; if not available report in skip
			try
				#compute DET data
				[Pmiss, Pfa] = Compute_DET(-d_client, -d_impostor);

				#set DET outputs
				output.DET_frr_rate = Pmiss;
				output.DET_far_rate = Pfa;    
				print('Finished with DETs!')
			catch
			   print('No DET-ware installed or not in Matlabs path! Make sure that NISTs DET-ware is present on your machine.')
			   print('You can download a gzipped tar-ball of the software from: http://www.nist.gov/itl/iad/mig/upload/DETware_v2-1-tar.gz')
			end




			#report to prompt
			print('Computing CMC curves ...')

			#finally we compute the cumulative match score curves - CMCs
			[rec_rates, ranks] = produce_CMC_PhD(results);


			#set CMC outputs
			output.CMC_rec_rates = rec_rates;
			output.CMC_ranks = ranks;

			print('Finished with CMCs!')




			#compute EPC curves if specified
			if EPC_flag==1

				#report to prompt
				print('Computing EPC curves and independant evaluation error rates ...')

				#as for the ROC curves - extract client and impostor scores

				 #get client distances
				cont_c = 1;
				for i=1:length(results1.client_horizontal_ids)
					for j=1:length(results1.client_vertical_ids)
						if results1.client_horizontal_ids(1,i)==results1.client_vertical_ids(1,j)
							d_client1(1,cont_c) = results1.client_dist(j,i);
							cont_c=cont_c+1;
						end 
					end
				end

				#get impostor distances 
				d_impostor1 = zeros(1,length(results1.imp_horizontal_ids)*length(results1.imp_vertical_ids));
				cont = 1;
				for i=1:length(results1.imp_horizontal_ids)
					for j=1:length(results1.imp_vertical_ids)
						d_impostor1(1,cont) = results1.imp_dist(j,i);
						cont=cont+1;
					end
				end


				#compute EPC curves
				[alpha,errors,rates_and_threshs1] = produce_EPC_PhD(d_client,d_impostor,d_client1,d_impostor1,rates_and_threshs,100);

				#set EPC outputs
				output.EPC_char_errors = rates_and_threshs1;
				output.EPC_alpha = alpha;
				output.EPC_errors = errors;    
			end    
		else
		   print('The entered decision mode is not supproted!')
		   return;        
		end

	 '''
	# MAIN2
	if results.mode == 'all':

		# account for the decision mode
		'''
		if strcmp(decision_mode,'ID')==1

			#compute the number of client and impostor ID-dependant experiments
			#to conduct
			[unique_id, ind, dummy] = unique(results.horizontal_ids);
			client_exp_num = sum(sum(results.same_cli_id(:,ind)));
			imp_exp_num = sum(sum(1-results.same_cli_id(:,ind)));

			#initialize client and impostor distance vectors
			d_client = zeros(1,client_exp_num);
			d_impostor = zeros(1,imp_exp_num);

			cont_c = 1;
			cont_i = 1;
			for j=1:length(unique_id) 
				[dum,ind] = find(unique_id(j)==results.horizontal_ids);
	#             scores_c = sub2ind(size(results.same_cli_id),dum,ind);
				for i=1:length(results.vertical_ids)
				   if results.vertical_ids(i)==unique_id(j)
						d_client(1,cont_c) = mean(results.match_dist(i,ind));
						cont_c=cont_c+1;
				   else
					   d_impostor(1,cont_i) = mean(results.match_dist(i,ind));
						cont_i=cont_i+1;
				   end
			   end
			end


			#compute ROC curve
			[ver_rate, miss_rate, rates_and_threshs] = produce_ROC_PhD(d_client, d_impostor, 5000);


			#set ROC outputs
			output.ROC_ver_rate = ver_rate;
			output.ROC_miss_rate = miss_rate;
			output.ROC_char_errors = rates_and_threshs;

			#report to prompt
			print('Finished with ROC, starting with DET if available.')

			#try to use Nists DET-ware; if not available report in skip
			try
				#compute DET data
				[Pmiss, Pfa] = Compute_DET(-d_client, -d_impostor);

				#set DET outputs
				output.DET_frr_rate = Pmiss;
				output.DET_far_rate = Pfa;    
				print('Finished with DETs!')
			catch
			   print('No DET-ware installed or not in Matlabs path! Make sure that NISTs DET-ware is present on your machine.')
			   print('You can download a gzipped tar-ball of the software from: http://www.itl.nist.gov/iad/mig/tools/DETware_v2.1.targz.htm')
			end


			#report to prompt
			print('Computing CMC curves ...')

			#finally we compute the cumulative match score curves - CMCs
			[rec_rates, ranks] = produce_CMC_PhD(results);


			#set CMC outputs
			output.CMC_rec_rates = rec_rates;
			output.CMC_ranks = ranks;

			print('Finished with CMCs!')




			 #compute EPC curves if specified
			if EPC_flag==1

				#report to prompt
				print('Computing EPC curves and independant evaluation error rates ...')

				#as for the ROC curves - extract client and impostor scores

				[unique_id, ind, dummy] = unique(results1.horizontal_ids);
				client_exp_num = sum(sum(results1.same_cli_id(:,ind)));
				imp_exp_num = sum(sum(1-results1.same_cli_id(:,ind)));

				#initialize client and impostor distance vectors
				d_client1 = zeros(1,client_exp_num);
				d_impostor1 = zeros(1,imp_exp_num);

				cont_c = 1;
				cont_i = 1;
				for j=1:length(unique_id) 
					[dum,ind] = find(unique_id(j)==results1.horizontal_ids);
		#             scores_c = sub2ind(size(results.same_cli_id),dum,ind);
					for i=1:length(results1.vertical_ids)
					   if results1.vertical_ids(i)==unique_id(j)
							d_client1(1,cont_c) = median(results1.match_dist(i,ind));
							cont_c=cont_c+1;
					   else
						   d_impostor1(1,cont_i) = median(results1.match_dist(i,ind));
							cont_i=cont_i+1;
					   end
				   end
				end


				#compute EPC curves
				[alpha,errors,rates_and_threshs1] = produce_EPC_PhD(d_client,d_impostor,d_client1,d_impostor1,rates_and_threshs,100);

				#set EPC outputs
				output.EPC_char_errors = rates_and_threshs1;
				output.EPC_alpha = alpha;
				output.EPC_errors = errors;    
			end
		'''
		if decision_mode == 'image':

			# compute the number of client and impostor experiments
			# to conduct
			client_exp_num = sum(sum(results.same_cli_id));

			imp_exp_num = sum(sum(1 - results.same_cli_id));

			# initialize client and impostor distance vectors
			d_client = np.zeros((1, int(client_exp_num)));
			d_impostor = np.zeros((1, int(imp_exp_num)));

			cont_c = 0;
			cont_i = 0;
			for j in range(0, len(results.horizontal_ids)):
				for i in range(0, len(results.vertical_ids)):
					if results.vertical_ids[i] == results.horizontal_ids[j]:
						d_client[0][cont_c] = np.median(results.match_dist[i][j]);
						cont_c = cont_c + 1;
					else:
						d_impostor[0][cont_i] = np.median(results.match_dist[i][j]);
						cont_i = cont_i + 1;
			# end

			# compute ROC curve
			from classification import ROC
			ver_rate, miss_rate, rates_and_threshs = ROC.produce_ROC_PhD(d_client, d_impostor, 5000);

			# set ROC outputs
			output.ROC_ver_rate = ver_rate;
			output.ROC_miss_rate = miss_rate;
			output.ROC_char_errors = rates_and_threshs;

			# report to prompt
			print('Finished with ROC, starting with DET ..')

			# try to use Nists DET-ware; if not available report in skip

			# compute DET data
			from classification import DET
			[Pmiss, Pfa] = DET.Compute_DET(-d_client, -d_impostor);

			# set DET outputs
			output.DET_frr_rate = Pmiss;
			output.DET_far_rate = Pfa;
			print('Finished with DETs!')
			'''
			catch
			   print('No DET-ware installed or not in Matlabs path! Make sure that NISTs DET-ware is present on your machine.')
			   print('You can download a gzipped tar-ball of the software from: http://www.itl.nist.gov/iad/mig/tools/DETware_v2.1.targz.htm')
			end
			'''
			'''
			print('ROC for this fold')
			import matplotlib.pyplot as plt
			plt.figure()
			plt.plot(output.DET_far_rate , output.DET_frr_rate,label=' ROC curve ',color='deeppink', linestyle='-', linewidth=4)
			plt.show()
			'''
			# .........................................................
			# report to prompt
			from classification import CMC
			# print('Computing CMC curves ...')
			print('Calculating Recognition Rates and Ranks...')

			# finally we compute the cumulative match score curves - CMCs
			[rec_rates, ranks] = CMC.produce_CMC_PhD(results, decision_mode);

			# set CMC outputs
			output.CMC_rec_rates = rec_rates;
			output.CMC_ranks = ranks;

			print('Finished with CMCs!')

			return output

			'''
			 #compute EPC curves if specified
			if EPC_flag==1:

				#report to prompt
				print('Computing EPC curves and independant evaluation error rates ...')

				#as for the ROC curves - extract client and impostor scores

				#compute the number of client and impostor experiments
				#to conduct
				client_exp_num = sum(sum(results1.same_cli_id));
				imp_exp_num = sum(sum(1-results1.same_cli_id));

				#initialize client and impostor distance vectors
				d_client1 = zeros(1,client_exp_num);
				d_impostor1 = zeros(1,imp_exp_num);

				cont_c = 1;
				cont_i = 1;
				for j=1:length(results1.horizontal_ids) 
					for i=1:length(results1.vertical_ids)
					   if results1.vertical_ids(i)==results1.horizontal_ids(j)
							d_client1(1,cont_c) = median(results1.match_dist(i,j));
							cont_c=cont_c+1;
					   else
						   d_impostor1(1,cont_i) = median(results1.match_dist(i,j));
							cont_i=cont_i+1;
					   end
				   end
				end


				#compute EPC curves
				[alpha,errors,rates_and_threshs1] = produce_EPC_PhD(d_client,d_impostor,d_client1,d_impostor1,rates_and_threshs,100);

				#set EPC outputs
				output.EPC_char_errors = rates_and_threshs1;
				output.EPC_alpha = alpha;
				output.EPC_errors = errors;    
			end 






		else
		   print('The entered decision mode is not supproted!')
		   return;        
		end  
	end

'''
